[
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Inward",
  "enabled": 1,
  "modified": "2025-07-22 17:43:03.548423",
  "module": "inwards",
  "name": "Inward Deduction - Populate Deduction Types",
  "script": "frappe.ui.form.on('Inward', {\n    refresh: function(frm) {\n        setup_deduction_types(frm);\n    }\n});\n\nfrappe.ui.form.on('Inward Deduction', {\n    deductions_add: function(frm, cdt, cdn) {\n        setup_deduction_types(frm);\n    },\n    \n    deduction_type: function(frm, cdt, cdn) {\n        let row = locals[cdt][cdn];\n        if (row.deduction_type) {\n            frappe.call({\n                method: 'frappe.desk.form.load.getdoc',\n                args: {\n                    doctype: 'App Settings',\n                    name: 'App Settings'\n                },\n                callback: function(r) {\n                    if (r.docs && r.docs[0] && r.docs[0].default_deduction_types) {\n                        r.docs[0].default_deduction_types.forEach(function(settings_row) {\n                            if (settings_row.deduction_name === row.deduction_type && settings_row.is_active) {\n                                frappe.model.set_value(cdt, cdn, 'amount', settings_row.default_amount || 0);\n                                frappe.model.set_value(cdt, cdn, 'description', settings_row.description || '');\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n});\n\nfunction setup_deduction_types(frm) {\n    frappe.call({\n        method: 'frappe.desk.form.load.getdoc',\n        args: {\n            doctype: 'App Settings',\n            name: 'App Settings'\n        },\n        callback: function(r) {\n            if (r.docs && r.docs[0] && r.docs[0].default_deduction_types) {\n                let options = [];\n                r.docs[0].default_deduction_types.forEach(function(row) {\n                    if (row.is_active) {\n                        options.push(row.deduction_name);\n                    }\n                });\n                \n                if (options.length > 0) {\n                    frm.fields_dict.deductions.grid.update_docfield_property('deduction_type', 'options', options.join('\\n'));\n                    frm.fields_dict.deductions.grid.refresh();\n                }\n            }\n        }\n    });\n}",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Sauda",
  "enabled": 1,
  "modified": "2025-09-25 11:11:07.054732",
  "module": null,
  "name": "Sauda-Basic-Calculation",
  "script": "\nfrappe.ui.form.on('Sauda', {\n    onload: function(frm) {\n        // Set default broker to 'self' when form loads\n        if (frm.is_new()) {\n            calculate_pending_values(frm);\n            frappe.db.get_list('Broker', {\n                filters: {'first_name': 'self'},\n                fields: ['name']\n            }).then(brokers => {\n                if (brokers.length > 0) {\n                    frm.set_value('broker', brokers[0].name);\n                }\n            });\n        }\n    },\n    refresh: function(frm) {\n        // Only calculate pending values for NEW documents\n        if (frm.is_new()) {\n            calculate_pending_values(frm);\n            frappe.db.get_list('Broker', {\n                filters: {'first_name': 'self'},\n                fields: ['name']\n            }).then(brokers => {\n                if (brokers.length > 0) {\n                    frm.set_value('broker', brokers[0].name);\n                }\n            });\n        }\n    },\n    \n    validate: function(frm) {\n        // Client-side validation before save/submit\n        validate_required_values(frm);\n    },\n    \n    expected_quantity: function(frm) {\n        calculate_total_amount(frm);\n        // Only update pending values for NEW documents\n        if (frm.is_new()) {\n            calculate_pending_values(frm);\n        }\n    },\n    \n    sauda_rate: function(frm) {\n        calculate_total_amount(frm);\n        // Only update pending values for NEW documents\n        if (frm.is_new()) {\n            calculate_pending_values(frm);\n        }\n    },\n    \n    total_amount: function(frm) {\n        // Only update pending values for NEW documents\n        if (frm.is_new()) {\n            calculate_pending_values(frm);\n        }\n    },\n    \n    booking_date: function(frm) {\n        calculate_dates(frm);\n    },\n    \n    delivery_duration: function(frm) {\n        calculate_dates(frm);\n    },\n    \n    payment_duration: function(frm) {\n        calculate_dates(frm);\n    }\n});\n\nfunction validate_required_values(frm) {\n    // Prevent submission with zero or invalid values\n    if (!frm.doc.expected_quantity || frm.doc.expected_quantity <= 0) {\n        frappe.throw(__(\"Expected Quantity must be greater than 0\"));\n        return false;\n    }\n    \n    if (!frm.doc.sauda_rate || frm.doc.sauda_rate <= 0) {\n        frappe.throw(__(\"Sauda Rate must be greater than 0\"));\n        return false;\n    }\n    \n    // if (!frm.doc.delivery_duration || frm.doc.delivery_duration <= 0) {\n    //     frappe.throw(__(\"Delivery Duration must be greater than 0\"));\n    //     return false;\n    // }\n    \n    // if (!frm.doc.payment_duration || frm.doc.payment_duration <= 0) {\n    //     frappe.throw(__(\"Payment Duration must be greater than 0\"));\n    //     return false;\n    // }\n    \n    return true;\n}\n\nfunction calculate_total_amount(frm) {\n    // Use KG to Quintal conversion like the other script\n    if (frm.doc.expected_quantity >= 0 && frm.doc.sauda_rate >= 0) {\n        let total = (frm.doc.expected_quantity / 100) * frm.doc.sauda_rate;\n        frm.set_value('total_amount', total);\n    }\n}\n\nfunction calculate_dates(frm) {\n    let booking_date = frm.doc.booking_date;\n    let delivery_duration = frm.doc.delivery_duration;\n    let payment_duration = frm.doc.payment_duration;\n    \n    if (booking_date) {\n        if (delivery_duration > 0) {\n            let delivery_end_date = frappe.datetime.add_days(booking_date, delivery_duration);\n            frm.set_value('delivery_end_date', delivery_end_date);\n        }\n        \n        if (payment_duration > 0) {\n            let payment_end_date = frappe.datetime.add_days(booking_date, payment_duration);\n            frm.set_value('payment_end_date', payment_end_date);\n        }\n    }\n}\n\nfunction calculate_pending_values(frm) {\n    // ONLY set initial pending values for NEW documents\n    if (frm.is_new() && frm.doc.expected_quantity >= 0) {\n        frm.set_value('pending_quantity', frm.doc.expected_quantity);\n    }\n    \n    if (frm.is_new() && frm.doc.total_amount >= 0) {\n        frm.set_value('pending_total_amount', frm.doc.total_amount);\n    }\n    \n    frm.refresh_fields(['pending_quantity', 'pending_total_amount']);\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Inward",
  "enabled": 1,
  "modified": "2025-08-26 13:56:46.395759",
  "module": null,
  "name": "Inward Item Amount Calculation",
  "script": "\n// Auto-populate fields when Sauda is selected\nfrappe.ui.form.on('Inward', {\n    sauda: function(frm) {\n        if (frm.doc.sauda) {\n            // Fetch Sauda document and populate fields\n            frappe.db.get_doc('Sauda', frm.doc.sauda).then(function(sauda_doc) {\n                frm.set_value('customer', sauda_doc.customer);\n                frm.set_value('warehouse', sauda_doc.warehouse);\n                frm.set_value('product', sauda_doc.product);\n                frm.set_value('company', sauda_doc.company);\n                frm.set_value('broker', sauda_doc.broker);\n            });\n        } else {\n            // Clear fields if Sauda is cleared\n            frm.set_value('customer', '');\n            frm.set_value('warehouse', '');\n            frm.set_value('product', '');\n            frm.set_value('company', '');\n            frm.set_value('broker', '');\n        }\n    },\n    \n    // Update Sauda pending quantities after Inward is saved\n    after_save: function(frm) {\n        if (frm.doc.sauda && frm.doc.total_arrival_weight && frm.doc.total_amount) {\n            update_sauda_pending_quantities(frm);\n        }\n    },\n    \n    cgst_percent: function(frm) {\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    sgst_percent: function(frm) {\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    igst_percent: function(frm) {\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    tcs_percent: function(frm) {\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    tds_percent: function(frm) {\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    broker_commission_percent: function(frm) {\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    }\n});\n\n// Calculate item_amount for each row in inward_items child table\nfrappe.ui.form.on('Inward Item Detail', {\n    item_arrival_weight: function(frm, cdt, cdn) {\n        calculate_item_amount(frm, cdt, cdn);\n        calculate_parent_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    item_rate: function(frm, cdt, cdn) {\n        calculate_item_amount(frm, cdt, cdn);\n        calculate_parent_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    item_gross_weight: function(frm, cdt, cdn) {\n        calculate_parent_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    bags: function(frm, cdt, cdn) {\n        calculate_parent_totals(frm);\n    },\n    \n    // Trigger when rows are added or removed\n    inward_items_add: function(frm, cdt, cdn) {\n        calculate_parent_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    inward_items_remove: function(frm, cdt, cdn) {\n        calculate_parent_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    }\n});\n\n// Calculate deductions when deductions child table changes\nfrappe.ui.form.on('Inward Deduction', {\n    amount: function(frm, cdt, cdn) {\n        calculate_deduction_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    // Trigger when deduction rows are added or removed\n    deductions_add: function(frm, cdt, cdn) {\n        calculate_deduction_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    },\n    \n    deductions_remove: function(frm, cdt, cdn) {\n        calculate_deduction_totals(frm);\n        calculate_financial_totals(frm);\n        calculate_tax_totals(frm);\n        calculate_net_total(frm);\n    }\n});\n\nfunction calculate_item_amount(frm, cdt, cdn) {\n    let row = locals[cdt][cdn];\n    \n    // Get values, default to 0 if empty\n    let arrival_weight = flt(row.item_arrival_weight) || 0;\n    let rate = flt(row.item_rate) || 0;\n    \n    // Calculate: item_amount = (item_arrival_weight / 100) × item_rate\n    let item_amount = (arrival_weight / 100) * rate;\n    \n    // Set the calculated value\n    frappe.model.set_value(cdt, cdn, 'item_amount', item_amount);\n    \n    // Refresh the field to show updated value\n    frm.refresh_field('inward_items');\n}\n\nfunction calculate_parent_totals(frm) {\n    let total_gross_weight = 0;\n    let total_bags = 0;\n    let total_arrival_weight = 0;\n    let total_amount = 0;\n    \n    // Loop through all rows in inward_items child table\n    if (frm.doc.inward_items) {\n        frm.doc.inward_items.forEach(function(row) {\n            total_gross_weight += flt(row.item_gross_weight) || 0;\n            total_bags += flt(row.bags) || 0;\n            total_arrival_weight += flt(row.item_arrival_weight) || 0;\n            total_amount += flt(row.item_amount) || 0;\n        });\n    }\n    \n    // Set parent totals\n    frm.set_value('total_gross_weight', total_gross_weight);\n    frm.set_value('total_bags', total_bags);\n    frm.set_value('total_arrival_weight', total_arrival_weight);\n    frm.set_value('total_amount', total_amount);\n}\n\nfunction calculate_deduction_totals(frm) {\n    let total_deductions = 0;\n    \n    // Loop through all rows in deductions child table\n    if (frm.doc.deductions) {\n        frm.doc.deductions.forEach(function(row) {\n            total_deductions += flt(row.amount) || 0;\n        });\n    }\n    \n    // Set total deductions\n    frm.set_value('total_deductions', total_deductions);\n}\n\nfunction calculate_financial_totals(frm) {\n    let total_amount = flt(frm.doc.total_amount) || 0;\n    let total_deductions = flt(frm.doc.total_deductions) || 0;\n    \n    // Calculate sub_total = total_amount - total_deductions\n    let sub_total = total_amount - total_deductions;\n    \n    // Set sub total\n    frm.set_value('sub_total', sub_total);\n}\n\nfunction calculate_tax_totals(frm) {\n    let sub_total = flt(frm.doc.sub_total) || 0;\n    \n    // Get tax percentages\n    let cgst_percent = flt(frm.doc.cgst_percent) || 0;\n    let sgst_percent = flt(frm.doc.sgst_percent) || 0;\n    let igst_percent = flt(frm.doc.igst_percent) || 0;\n    let tcs_percent = flt(frm.doc.tcs_percent) || 0;\n    let tds_percent = flt(frm.doc.tds_percent) || 0;\n    let broker_commission_percent = flt(frm.doc.broker_commission_percent) || 0;\n    \n    // Calculate tax amounts\n    let cgst_amount = sub_total * cgst_percent / 100;\n    let sgst_amount = sub_total * sgst_percent / 100;\n    let igst_amount = sub_total * igst_percent / 100;\n    let total_gst_amount = sub_total * (cgst_percent + sgst_percent + igst_percent) / 100;\n    let tcs_amount = sub_total * tcs_percent / 100;\n    let tds_amount = sub_total * tds_percent / 100;\n    let broker_commission_amount = sub_total * broker_commission_percent / 100;\n    \n    // Set tax amounts\n    frm.set_value('cgst_amount', cgst_amount);\n    frm.set_value('sgst_amount', sgst_amount);\n    frm.set_value('igst_amount', igst_amount);\n    frm.set_value('total_gst_amount', total_gst_amount);\n    frm.set_value('tcs_amount', tcs_amount);\n    frm.set_value('tds_amount', tds_amount);\n    frm.set_value('broker_commission_amount', broker_commission_amount);\n}\n\nfunction calculate_net_total(frm) {\n    let sub_total = flt(frm.doc.sub_total) || 0;\n    let total_gst_amount = flt(frm.doc.total_gst_amount) || 0;\n    let tcs_amount = flt(frm.doc.tcs_amount) || 0;\n    let tds_amount = flt(frm.doc.tds_amount) || 0;\n    \n    // Calculate net_total = sub_total + total_gst_amount + tcs_amount - tds_amount\n    let net_total = sub_total + total_gst_amount + tcs_amount - tds_amount;\n    \n    // Set net total\n    frm.set_value('net_total', net_total);\n}\n\nfunction update_sauda_pending_quantities(frm) {\n    frappe.db.get_doc('Sauda', frm.doc.sauda).then(function(sauda_doc) {\n        let current_pending_quantity = flt(sauda_doc.pending_quantity) || 0;\n        let current_pending_amount = flt(sauda_doc.pending_total_amount) || 0;\n        \n        let inward_quantity = flt(frm.doc.total_arrival_weight) || 0;\n        let inward_amount = flt(frm.doc.total_amount) || 0;\n        \n        let new_pending_quantity = Math.max(0, current_pending_quantity - inward_quantity);\n        let new_pending_amount = Math.max(0, current_pending_amount - inward_amount);\n        \n        // Use frappe.call for more reliable updates\n        frappe.call({\n            method: 'frappe.client.set_value',\n            args: {\n                doctype: 'Sauda',\n                name: frm.doc.sauda,\n                fieldname: {\n                    'pending_quantity': new_pending_quantity,\n                    'pending_total_amount': new_pending_amount\n                }\n            },\n            callback: function(response) {\n                frappe.show_alert({\n                    message: 'Sauda pending quantities updated successfully',\n                    indicator: 'green'\n                });\n                \n                // Force refresh any open Sauda forms\n                frappe.ui.form.refresh_form_if_exists('Sauda', frm.doc.sauda);\n            }\n        });\n    });\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Inward",
  "enabled": 1,
  "modified": "2025-07-30 20:52:23.990105",
  "module": null,
  "name": "Inward Deduction Auto-calculations",
  "script": "\nfrappe.ui.form.on('Inward', {\n    refresh: function(frm) {\n        set_deduction_options(frm);\n    },\n    \n    onload: function(frm) {\n        set_deduction_options(frm);\n    }\n});\n\nfrappe.ui.form.on('Inward Deduction', {\n    deduction_type: function(frm, cdt, cdn) {\n        let row = locals[cdt][cdn];\n        \n        if (row.deduction_type) {\n            fetch_master_values(frm, cdt, cdn, row.deduction_type);\n        }\n    },\n    \n    actual_value: function(frm, cdt, cdn) {\n        calculate_amounts(frm, cdt, cdn);\n        calculate_total_deductions(frm);\n        // Trigger existing sub_total calculation\n        calculate_financial_totals(frm);\n    },\n    \n    required_value: function(frm, cdt, cdn) {\n        calculate_amounts(frm, cdt, cdn);\n        calculate_total_deductions(frm);\n        calculate_financial_totals(frm);\n    },\n    \n    charges_per_unit: function(frm, cdt, cdn) {\n        calculate_amounts(frm, cdt, cdn);\n        calculate_total_deductions(frm);\n        calculate_financial_totals(frm);\n    },\n    \n    deduction_amount: function(frm, cdt, cdn) {\n        calculate_total_deductions(frm);\n        calculate_financial_totals(frm);\n    },\n    \n    deductions_add: function(frm) {\n        // Delay to ensure row is added\n        setTimeout(() => {\n            set_deduction_options(frm);\n            calculate_total_deductions(frm);\n            calculate_financial_totals(frm);\n        }, 100);\n    },\n    \n    deductions_remove: function(frm) {\n        setTimeout(() => {\n            calculate_total_deductions(frm);\n            calculate_financial_totals(frm);\n        }, 100);\n    }\n});\n\nfunction set_deduction_options(frm) {\n    frappe.call({\n        method: 'frappe.desk.form.load.getdoc',\n        args: {\n            doctype: 'App Settings',\n            name: 'App Settings'\n        },\n        callback: function(r) {\n            if (r.docs && r.docs[0] && r.docs[0].default_deduction_types) {\n                let types = r.docs[0].default_deduction_types.filter(t => t.is_active === 1);\n                let options = types.map(t => t.deduction_name);\n                \n                // Safer option setting\n                try {\n                    if (frm.fields_dict.deductions && \n                        frm.fields_dict.deductions.grid && \n                        frm.fields_dict.deductions.grid.get_field('deduction_type')) {\n                        \n                        frm.fields_dict.deductions.grid.get_field('deduction_type').df.options = options.join('\\n');\n                        frm.refresh_field('deductions');\n                    }\n                } catch(e) {\n                    console.log('Note: Deduction field not ready yet');\n                }\n            }\n        }\n    });\n}\n\nfunction fetch_master_values(frm, cdt, cdn, deduction_type) {\n    frappe.call({\n        method: 'frappe.desk.form.load.getdoc',\n        args: {\n            doctype: 'App Settings',\n            name: 'App Settings'\n        },\n        callback: function(r) {\n            if (r.docs && r.docs[0] && r.docs[0].default_deduction_types) {\n                let selected = r.docs[0].default_deduction_types.find(\n                    t => t.deduction_name === deduction_type && t.is_active === 1\n                );\n                \n                if (selected) {\n                    frappe.model.set_value(cdt, cdn, 'required_value', selected.required_value || 0);\n                    frappe.model.set_value(cdt, cdn, 'charges_per_unit', selected.charges_per_unit || 0);\n                    \n                    let row = locals[cdt][cdn];\n                    if (row.actual_value) {\n                        calculate_amounts(frm, cdt, cdn);\n                    }\n                    calculate_total_deductions(frm);\n                    calculate_financial_totals(frm);\n                }\n            }\n        }\n    });\n}\n\nfunction calculate_amounts(frm, cdt, cdn) {\n    let row = locals[cdt][cdn];\n    \n    if (row.actual_value >= 0 && row.required_value >= 0 && row.charges_per_unit >= 0) {\n        let difference = 0;\n        let amount = 0;\n        \n        if (flt(row.actual_value) > flt(row.required_value)) {\n            difference = flt(row.actual_value) - flt(row.required_value);\n            amount = difference * flt(row.charges_per_unit);\n        }\n        \n        frappe.model.set_value(cdt, cdn, 'difference_value', difference);\n        frappe.model.set_value(cdt, cdn, 'deduction_amount', amount);\n    }\n}\n\nfunction calculate_total_deductions(frm) {\n    let total = 0;\n    \n    if (frm.doc.deductions) {\n        frm.doc.deductions.forEach(function(row) {\n            total += flt(row.deduction_amount) || 0;\n        });\n    }\n    \n    frm.set_value('total_deductions', total);\n}\n\n// Make functions available to other scripts\nwindow.calculate_financial_totals = function(frm) {\n    let total_amount = flt(frm.doc.total_amount) || 0;\n    let total_deductions = flt(frm.doc.total_deductions) || 0;\n    \n    let sub_total = total_amount - total_deductions;\n    frm.set_value('sub_total', sub_total);\n};\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Sauda",
  "enabled": 1,
  "modified": "2025-08-19 13:06:46.575812",
  "module": null,
  "name": "Sauda Total Amount Calculation",
  "script": "\n// Calculate total_amount when expected_quantity or sauda_rate changes\nfrappe.ui.form.on('Sauda', {\n    expected_quantity: function(frm) {\n        calculate_total_amount(frm);\n    },\n    \n    sauda_rate: function(frm) {\n        calculate_total_amount(frm);\n    }\n});\n\nfunction calculate_total_amount(frm) {\n    // Get values, default to 0 if empty\n    let expected_quantity = flt(frm.doc.expected_quantity) || 0;\n    let sauda_rate = flt(frm.doc.sauda_rate) || 0;\n    \n    // Calculate: total_amount = (expected_quantity / 100) × sauda_rate (KG to Quintal conversion)\n    let total_amount = (expected_quantity / 100) * sauda_rate;\n    \n    // Set the calculated value\n    frm.set_value('total_amount', total_amount);\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Inward",
  "enabled": 1,
  "modified": "2025-09-25 13:03:51.045608",
  "module": null,
  "name": "Inward Auto Calculations",
  "script": "\n// ===============================================\n// INWARD DOCTYPE CLIENT SCRIPT - UPDATED\n// ===============================================\n\nfrappe.ui.form.on('Inward', {\n    onload: function(frm) {\n        if (frm.is_new()) {\n            // add_default_bag_types(frm);\n            if (!frm.doc.report_type) {\n            frm.set_value('report_type', 'Multi Report');\n            }\n            \n            load_items_by_report_type(frm);\n        \n            // Load default items based on current report type after form loads\n            // setTimeout(() => {\n            //   \n            // }, 500);\n            \n            // Wait for child table to load properly\n            setTimeout(function() {\n                calculate_bag_count(frm, function() {\n                    setTimeout(function() {\n                        auto_populate_deductions(frm);\n                    }, 100);\n                });\n            }, 200);\n        }\n        \n        load_bag_type_options(frm);\n    },\n    \n    refresh: function(frm) {\n        // Calculate all totals when form loads\n        calculate_all_totals(frm);\n        if(frm.doc.customer) {\n            frappe.db.get_value('Customer', frm.doc.customer, 'customer_type')\n            .then(r => {\n                if(r.message.customer_type === 'Company / Trader') {\n                    frm.set_df_property('vendor_gstin', 'hidden', 0);\n                }\n                else if(customer_type === 'Individual / Farmers')\n                {\n                    frm.set_df_property('vendor_gstin', 'hidden', 1);\n                }\n                    \n            });\n        }\n        \n        \n        // if (frm.doc.report_type) {\n        //     load_items_by_report_type(frm);\n        // }\n        \n    },\n    \n    // ===========================================\n    // SAUDA SELECTION - AUTO POPULATE\n    // ===========================================\n    sauda: function(frm) {\n        if (frm.doc.sauda) {\n            // Auto-populate fields from selected Sauda\n            frappe.db.get_doc('Sauda', frm.doc.sauda).then(sauda_doc => {\n                frm.set_value('customer', sauda_doc.customer);\n                frm.set_value('warehouse', sauda_doc.warehouse);\n                frm.set_value('product', sauda_doc.product);\n                frm.set_value('broker', sauda_doc.broker);\n                frm.set_value('payment_due_date', sauda_doc.payment_end_date);\n                frm.set_value('gross_weight', sauda_doc.expected_quantity);\n                frm.set_value('rate_per_quintal', sauda_doc.sauda_rate);\n                frm.set_value('vendor_amount', sauda_doc.total_amount);\n                \n                // Fill child table (item_details) rates also\n                if (frm.doc.inward_items && frm.doc.inward_items.length > 0) {\n                    \n                    if (frm.doc.report_type === 'Multi Rate') {\n                        // Multi Rate Report: Set rate only to FIRST row\n                        let first_row = frm.doc.inward_items[0];\n                        frappe.model.set_value(first_row.doctype, first_row.name, \"item_rate\", frm.doc.rate_per_quintal);\n                        \n                    } else {\n                        // Other Reports: Set rate to ALL rows (original logic)\n                        frm.doc.inward_items.forEach(row => {\n                            frappe.model.set_value(row.doctype, row.name, \"item_rate\", frm.doc.rate_per_quintal);\n                        });\n                    }\n                    \n                    frm.refresh_field(\"inward_items\");\n                }\n                });\n        }\n    },\n    \n    broker: function(frm) {\n        if (frm.doc.broker) {\n            frappe.db.get_value('Broker', frm.doc.broker, 'commission_rate')\n                .then(r => {\n                    if (r.message && r.message.commission_rate) {\n                        frm.set_value('broker_commission_percent', r.message.commission_rate);\n                    }\n                });\n        } else {\n            frm.set_value('broker_commission_percent', 0);\n        }\n    },\n    \n    customer: function(frm) {\n        if (frm.doc.customer) {\n            // Fetch customer_type, gstin, and tax information from Customer doctype\n            frappe.db.get_value('Customer', frm.doc.customer, \n                ['customer_type', 'gstin', 'cgst_percent', 'sgst_percent', 'igst_percent'])\n            .then(r => {\n                if (r.message) {\n                    let customer_type = r.message.customer_type;\n                    let gstin = r.message.gstin;\n                    \n                    // Existing logic for vendor_gstin\n                    if (customer_type === 'Company / Trader') {\n                        frm.set_df_property('vendor_gstin', 'hidden', 0);\n                        frm.set_value('vendor_gstin', gstin);\n                    }\n                    else if(customer_type === 'Individual / Farmers') {\n                        frm.set_df_property('vendor_gstin', 'hidden', 1);\n                    }\n                    \n                    // New logic for tax auto-fill\n                    frm.set_value('cgst_percent', r.message.cgst_percent || 0);\n                    frm.set_value('sgst_percent', r.message.sgst_percent || 0);\n                    frm.set_value('igst_percent', r.message.igst_percent || 0);\n                }\n            });\n        } else {\n            // Clear fields when customer is cleared\n            frm.set_df_property('vendor_gstin', 'hidden', 1);\n            frm.set_value('vendor_gstin', '');\n            frm.set_value('cgst_percent', 0);\n            frm.set_value('sgst_percent', 0);\n            frm.set_value('igst_percent', 0);\n        }\n    },\n    \n    // Trigger when rate_per_quintal changes\n\n    rate_per_quintal: function(frm) {\n        if (frm.doc.inward_items && frm.doc.inward_items.length > 0) {\n            \n            if (frm.doc.report_type === 'Multi Rate') {\n                // Multi Rate Report: Set rate only to FIRST row\n                let first_row = frm.doc.inward_items[0];\n                frappe.model.set_value(first_row.doctype, first_row.name, \"item_rate\", frm.doc.rate_per_quintal);\n                \n            } else {\n                // Other Reports: Set rate to ALL rows (original logic)\n                frm.doc.inward_items.forEach(row => {\n                    frappe.model.set_value(row.doctype, row.name, \"item_rate\", frm.doc.rate_per_quintal);\n                });\n            }\n            \n            frm.refresh_field(\"inward_items\");\n        }\n        calculate_and_update_debit_note(frm);\n    },\n    \n    sub_total: function(frm) {\n        calculate_and_update_debit_note(frm);\n    },\n    \n    vendor_amount: function(frm) {\n        calculate_and_update_debit_note(frm);\n    },\n    \n    gross_weight: function(frm,cdt,cdn) {\n        update_first_row_bag_type(frm);\n        \n        // if (frm.doc.report_type === 'Multi Report') {\n        //     frm.doc.inward_items.forEach(function(row, index) {\n        //         calculate_all_bags_weights(frm, row.doctype, row.name);\n        //     });\n        // }\n        \n        update_unloading_deduction(frm);\n        calculate_and_update_debit_note(frm);\n    },\n    \n    // event triggers when the Select field value changes\n    report_type: function(frm) {\n        // Load items based on new selection\n        if (frm.doc.report_type) {\n            load_items_by_report_type(frm);\n        }\n        \n        // Wait for table to load, then calculate in correct sequence\n       setTimeout(function() {\n            if (frm.doc.inward_items && frm.doc.inward_items.length > 0) {\n                \n                // Check if this is a single report\n                 if (frm.doc.report_type === 'Single Report') {\n                    \n                    // Get the single row\n                    let row = frm.doc.inward_items[0];\n                    \n                    // Calculate bag weights for the single row\n                    calculate_all_bags_weights(frm, row.doctype, row.name);\n                    \n                    // Calculate item totals after bag weights are done\n                    setTimeout(function() {\n                        calculate_item_totals(frm);\n                    }, 200);\n                }\n            }\n        }, 800);\n    },\n    \n      // Auto-populate item_bag_type when inward_total_bags changes (only for Single Report and Multi Rate Report - first row only)\n    inward_total_bags: function(frm) {\n        update_first_row_bag_type(frm);\n    },\n    \n    total_amount: function(frm) {\n        update_others_deduction(frm);\n    },\n    \n    net_total: function(frm) {\n        if (frm.doc.net_total) {\n            // Floor the value\n            let floored = Math.floor(frm.doc.net_total);\n\n            // Format as .00\n            floored = floored.toFixed(2);\n\n            frm.set_value(\"net_total\", floored);\n        }\n    },\n    \n    // bag_type_count: function(frm) {\n    //     auto_populate_deductions(frm);\n    // },\n\n    // ===========================================\n    // TAX PERCENTAGE TRIGGERS\n    // ===========================================\n    cgst_percent: function(frm) { calculate_taxes(frm); },\n    sgst_percent: function(frm) { calculate_taxes(frm); },\n    igst_percent: function(frm) { calculate_taxes(frm); },\n    tcs_percent: function(frm) { calculate_taxes(frm); },\n    tds_percent: function(frm) { calculate_taxes(frm); },\n    broker_commission_percent: function(frm) { calculate_taxes(frm); }\n});\n\n// ===============================================\n// CHILD TABLE: INWARD ITEM DETAIL\n// ===============================================\nfrappe.ui.form.on('Inward Item Detail', {\n    // When child table is modified\n    inward_items_add: function(frm,cdt,cdn) {\n        calculate_item_totals(frm);\n        calculate_bag_count(frm);\n        auto_populate_deductions(frm, true);\n        \n        if (frm.doc.report_type === 'Multi Rate') {\n            let new_row = locals[cdt][cdn];\n            let row_index = new_row.idx;\n            \n            // Auto-populate item_bags = 0 for new rows\n            // frappe.model.set_value(cdt, cdn, 'item_bags', 0);\n            \n            // Auto-populate arrival weight from 2nd row onwards\n            if (row_index >= 2) {\n                setTimeout(() => {\n                    calculate_auto_gross_weight(frm, cdt, cdn);\n                }, 300);\n            }\n        }\n    },\n    \n    before_inward_items_remove: function(frm, cdt, cdn) {\n        let item_row = locals[cdt][cdn];\n        let deleted_item_index = item_row.idx - 1;\n        frm._deleted_item_index = deleted_item_index;\n        // Capture whether the deleted item was plastic\n        frm._deleted_item_was_plastic = item_row && item_row.item_bag_type && item_row.item_bag_type.toLowerCase() === 'plastic';\n    },\n    \n    inward_items_remove: function(frm, cdt, cdn) {\n        \n        let was_plastic = frm._deleted_item_was_plastic || false;\n        \n        calculate_item_totals(frm);\n        calculate_bag_count(frm);\n        if (frm.doc.report_type !== 'Multi Rate' && frm._deleted_item_index !== undefined) {\n            remove_mapped_deduction_rows(frm, frm._deleted_item_index);\n            delete frm._deleted_item_index;\n        }\n  \n        if (was_plastic && !has_plastic_bag_type(frm)) {\n            \n            remove_pp_deduction(frm);\n            update_pp_deduction(frm);\n            delete frm._deleted_item_was_plastic;\n        }\n        \n        if (was_plastic && has_plastic_bag_type(frm)) {\n            update_pp_deduction(frm);\n        }\n        \n        \n    },\n    \n    // Individual item calculations\n    item_arrival_weight: function(frm, cdt, cdn) {\n        if (frm.doc.report_type === 'Multi Rate') {\n            calculate_multi_rate_amount(frm, cdt, cdn);\n        }\n        calculate_item_amount(frm, cdt, cdn);\n        calculate_item_totals(frm);\n    },\n    \n    item_rate: function(frm, cdt, cdn) {\n        if (frm.doc.report_type === 'Multi Rate') {\n            calculate_multi_rate_amount(frm, cdt, cdn);\n        }\n        calculate_item_amount(frm, cdt, cdn);\n        calculate_item_totals(frm);\n        update_related_deductions(frm);\n    },\n    \n    item_gross_weight: function(frm, cdt, cdn) {\n        let row = locals[cdt][cdn];\n        if (frm.doc.report_type === 'Multi Rate') {\n            calculate_multi_rate_amount(frm, cdt, cdn);\n            let new_row = locals[cdt][cdn];\n            let row_index = new_row.idx;\n            \n            // Auto-populate item_bags = 0 for new rows\n            // frappe.model.set_value(cdt, cdn, 'item_bags', 0);\n            \n            // Auto-populate arrival weight for 2nd row\n            // if (row_index == 2) {\n            //     setTimeout(() => {\n            //         calculate_auto_gross_weight(frm, cdt, cdn);\n            //     }, 300);\n            // }\n        }\n        \n        if (frm.doc.report_type === 'Single Report') {\n            calculate_all_bags_weights(frm, cdt, cdn);\n        }\n        calculate_item_totals(frm);\n        update_related_deductions(frm);\n        \n        // If this row is plastic, update PP deduction amount\n        if (row.item_bag_type && row.item_bag_type.toLowerCase() === 'plastic') {\n            update_pp_deduction(frm);\n        }\n        \n    },\n    \n    item_amount: function(frm, cdt, cdn) {\n        update_related_deductions(frm);\n    },\n    \n    bags: function(frm, cdt, cdn) {\n        calculate_item_totals(frm);\n        \n    },\n    \n    item_bags: function(frm, cdt, cdn) {\n        validate_bag_count(frm);\n        if (frm.doc.report_type === 'Multi Rate') {\n            // calculate_multi_rate_amount(frm, cdt, cdn);\n        } else {\n            update_deduction_bags_for_item(frm, cdt, cdn);\n            calculate_all_bags_weights(frm, cdt, cdn);\n        }\n        update_related_deductions(frm);\n    },\n    \n    item_bag_type: function(frm, cdt, cdn) {\n        let row = locals[cdt][cdn];\n        \n        if (row.item_bag_type) {\n            // Step 1: Start async call\n            frappe.call({\n                method: 'frappe.client.get',\n                args: {\n                    doctype: 'App Settings',\n                    name: 'App Settings'\n                },\n                callback: function(response) {\n                    if (response.message && response.message.default_bag_types) {\n                        // Step 2: Find and set charges\n                        response.message.default_bag_types.forEach(function(bag_row) {\n                            if (bag_row.bag_type === row.item_bag_type) {\n                                // Step 3: Set the charges\n                                frappe.model.set_value(cdt, cdn, 'item_charges', bag_row.charges);\n                                \n                                // Step 4: NOW calculate with CORRECT charges\n                                if (frm.doc.report_type === 'Multi Rate') {\n                                    calculate_multi_rate_amount(frm, cdt, cdn);\n                                } else {\n                                    calculate_all_bags_weights(frm, cdt, cdn);\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        } else {\n            // Handle case when no bag type is selected\n            if (frm.doc.report_type === 'Multi Rate') {\n                calculate_multi_rate_amount(frm, cdt, cdn);\n            } else {\n                calculate_all_bags_weights(frm, cdt, cdn);\n            }\n        }\n        update_related_deductions(frm);\n        \n        if (row.item_bag_type && row.item_bag_type.toLowerCase() === 'plastic') {\n            check_and_add_pp_deduction(frm);\n             update_pp_deduction(frm);\n        } else {\n            if (!has_plastic_bag_type(frm)) {\n                remove_pp_deduction(frm);\n                update_pp_deduction(frm);\n            }\n            else\n            {\n                update_pp_deduction(frm);\n            }\n        }\n    },\n});\n\n// ===============================================\n// CHILD TABLE: INWARD DEDUCTION\n// ===============================================\nfrappe.ui.form.on('Inward Deduction', {\n    deductions_add: function(frm) {\n        calculate_deduction_totals(frm);\n    },\n    \n    deductions_remove: function(frm) {\n        calculate_deduction_totals(frm);\n    },\n    \n    deduction_amount: function(frm) {\n        calculate_deduction_totals(frm);\n    },\n    \n    actual_value: function(frm, cdt, cdn) {\n        calculate_deduction_amount(frm, cdt, cdn);\n    },\n    \n    required_value: function(frm, cdt, cdn) {\n        calculate_deduction_amount(frm, cdt, cdn);\n    }\n});\n\n// ===============================================\n// CHILD TABLE: INWARD PAYMENT\n// ===============================================\nfrappe.ui.form.on('Inward Payment', {\n    inward_payments_add: function(frm) {\n        calculate_payment_totals(frm);\n    },\n    \n    inward_payments_remove: function(frm) {\n        calculate_payment_totals(frm);\n    },\n    \n    payment_amount: function(frm) {\n        calculate_payment_totals(frm);\n    },\n    \n    payment_status: function(frm) {\n        calculate_payment_totals(frm);\n    }\n});\n\n\n// ===============================================\n// CALCULATION FUNCTIONS\n// ===============================================\n\nfunction calculate_item_amount(frm, cdt, cdn) {\n    // Calculate item_amount for individual row\n    let row = locals[cdt][cdn];\n    \n    if (row.item_arrival_weight >= 0 && row.item_rate >= 0) {\n        // KG to Quintal conversion: item_amount = (arrival_weight / 100) * rate\n        row.item_amount = (row.item_arrival_weight / 100) * row.item_rate;\n        frm.refresh_field('inward_items');\n    }\n}\n\nfunction calculate_item_totals(frm) {\n    // Calculate parent totals from inward_items child table\n    let total_gross_weight = 0;\n    let total_bags = 0;\n    let total_arrival_weight = 0;\n    let total_amount = 0;\n    \n    if (frm.doc.inward_items) {\n        frm.doc.inward_items.forEach(function(item) {\n            if (item.item_gross_weight) total_gross_weight += item.item_gross_weight;\n            if (item.item_bags) total_bags += item.item_bags;\n            if (item.item_arrival_weight) total_arrival_weight += item.item_arrival_weight;\n            if (item.item_amount) total_amount += item.item_amount;\n        });\n    }\n\n    frm.set_value('total_gross_weight', total_gross_weight);\n    frm.set_value('total_bags', total_bags);\n    frm.set_value('total_arrival_weight', total_arrival_weight);\n    frm.set_value('total_amount', total_amount);\n    \n    // Trigger dependent calculations\n    calculate_sub_total(frm);\n}\n\nfunction calculate_deduction_totals(frm) {\n    // Calculate total_deductions from deductions child table\n    let total_deductions = 0;\n    \n    if (frm.doc.deductions) {\n        frm.doc.deductions.forEach(function(deduction) {\n            if (deduction.deduction_amount) {\n                total_deductions += deduction.deduction_amount;\n            }\n        });\n    }\n    \n    frm.set_value('total_deductions', total_deductions);\n    \n    // Trigger dependent calculations\n    calculate_sub_total(frm);\n}\n\nfunction calculate_sub_total(frm) {\n    // Calculate sub_total = total_amount - total_deductions\n    let sub_total = (frm.doc.total_amount || 0) - (frm.doc.total_deductions || 0);\n    frm.set_value('sub_total', sub_total);\n    \n    // Trigger tax calculations\n    calculate_taxes(frm);\n}\n\nfunction calculate_taxes(frm) {\n    // Calculate all tax amounts based on sub_total\n    let sub_total = frm.doc.sub_total || 0;\n    let total_gross_weight = frm.doc.total_gross_weight || 0;\n    \n    // GST Calculation\n    let cgst_percent = frm.doc.cgst_percent || 0;\n    let sgst_percent = frm.doc.sgst_percent || 0;\n    let igst_percent = frm.doc.igst_percent || 0;\n    let total_gst_amount = sub_total * (cgst_percent + sgst_percent + igst_percent) / 100;\n    \n    // TCS Calculation\n    let tcs_percent = frm.doc.tcs_percent || 0;\n    let tcs_amount = sub_total * tcs_percent / 100;\n    \n    // TDS Calculation\n    let tds_percent = frm.doc.tds_percent || 0;\n    let tds_amount = sub_total * tds_percent / 100;\n    \n    // Broker Commission Calculation (for records only)\n    let broker_commission_percent = frm.doc.broker_commission_percent || 0;\n    let broker_commission_amount = total_gross_weight * broker_commission_percent / 100;\n    \n    // Set calculated values\n    frm.set_value('total_gst_amount', total_gst_amount);\n    frm.set_value('tcs_amount', tcs_amount);\n    frm.set_value('tds_amount', tds_amount);\n    frm.set_value('broker_commission_amount', broker_commission_amount);\n    \n    // Calculate final net_total\n    calculate_net_total(frm);\n}\n\nfunction calculate_net_total(frm) {\n    // Calculate net_total = sub_total + total_gst_amount + tcs_amount - tds_amount\n    let sub_total = frm.doc.sub_total || 0;\n    let total_gst_amount = frm.doc.total_gst_amount || 0;\n    let tcs_amount = frm.doc.tcs_amount || 0;\n    let tds_amount = frm.doc.tds_amount || 0;\n    \n    let net_total = sub_total + total_gst_amount + tcs_amount - tds_amount;\n    frm.set_value('net_total', net_total);\n    \n    // Trigger payment calculations\n    calculate_payment_totals(frm);\n}\n\nfunction calculate_payment_totals(frm) {\n    // Calculate payment summary from inward_payments child table\n    let total_amount_paid = 0;\n    let last_payment_date = null;\n    let has_pending_payments = false;\n    let has_completed_payments = false;\n    \n    if (frm.doc.inward_payments) {\n        frm.doc.inward_payments.forEach(function(payment) {\n            // Only count success payments in total_amount_paid\n            if (payment.payment_status === 'success' && payment.payment_amount) {\n                total_amount_paid += payment.payment_amount;\n                has_completed_payments = true;\n                \n                // Track latest payment date\n                if (payment.payment_date) {\n                    if (!last_payment_date || payment.payment_date > last_payment_date) {\n                        last_payment_date = payment.payment_date;\n                    }\n                }\n            }\n            \n            // Check for pending payments\n            if (payment.payment_status === 'pending') {\n                has_pending_payments = true;\n            }\n        });\n    }\n    \n    // Calculate pending amount\n    let net_total = frm.doc.net_total || 0;\n    let total_amount_pending = net_total - total_amount_paid;\n    \n    // Determine overall payment status using new status names\n    let inward_payment_status = 'pending';\n    if (total_amount_paid >= net_total) {\n        inward_payment_status = 'success';\n    } else if (total_amount_paid > 0) {\n        inward_payment_status = 'processing';\n    }\n    \n    // Set calculated values\n    frm.set_value('total_amount_paid', total_amount_paid);\n    frm.set_value('total_amount_pending', Math.max(0, total_amount_pending));\n    frm.set_value('inward_payment_status', inward_payment_status);\n    frm.set_value('last_payment_date', last_payment_date);\n}\n\nfunction calculate_all_totals(frm) {\n    // Master function to recalculate everything\n    calculate_item_totals(frm);\n    calculate_deduction_totals(frm);\n    calculate_payment_totals(frm);\n}\n\n\nfunction calculate_all_bags_weights(frm, cdt, cdn) {\n    let row = locals[cdt][cdn];\n    \n    // Calculate Average weight\n    let average_weight_per_bag = frm.doc.gross_weight / frm.doc.inward_total_bags;\n    \n    // Calculate total bag weight for each bag\n    let deduct_bag_weight = row.item_bags * row.item_charges;\n    \n    // Get current value\n    let current_value = frappe.model.get_value(cdt, cdn, 'item_gross_weight');\n    \n    \n    let item_gross_weight = row.item_bags * average_weight_per_bag;\n    \n    \n    // Handle NaN and comparison properly\n    let should_update = false;\n    \n    if (isNaN(current_value) && !isNaN(item_gross_weight)) {\n        // Current is NaN but new value is valid number\n        should_update = true;\n    } else if (!isNaN(current_value) && !isNaN(item_gross_weight) && current_value !== item_gross_weight) {\n        // Both are valid numbers but different\n        should_update = true;\n    } else if (isNaN(current_value) && isNaN(item_gross_weight)) {\n        // Both are NaN, no need to update\n        should_update = false;\n    }\n    \n    // Only set if value should be updated\n    if (should_update) {\n        frappe.model.set_value(cdt, cdn, 'item_gross_weight', item_gross_weight);\n    }\n    \n    frappe.model.set_value(cdt, cdn, 'item_deduct_weight', deduct_bag_weight);\n    \n    // Calculate arrival weight\n    // Arrival Weight = (No of bags × Average weight per bag) - Deduct weight\n    if (row.item_bags || row.item_gross_weight) {\n        let item_arrival_weight = (row.item_bags * average_weight_per_bag) - deduct_bag_weight;\n        frappe.model.set_value(cdt, cdn, 'item_arrival_weight', item_arrival_weight);\n    }\n    frm.refresh_field('items');\n}\n\nfunction calculate_multi_rate_amount(frm, cdt, cdn) {\n    // Only calculate for Multi Rate Report\n    if (frm.doc.report_type !== 'Multi Rate') {\n        return;\n    }\n    \n    let row = locals[cdt][cdn];\n    \n    \n    // Calculate Average weight\n    let average_weight_per_bag = frm.doc.gross_weight/frm.doc.inward_total_bags;\n    \n    // Calculate No of Bags\n    let no_of_bags = parseInt(row.item_gross_weight / average_weight_per_bag);\n    frappe.model.set_value(cdt, cdn, 'item_bags', no_of_bags);\n        \n    // ========================================\n    // 1. CALCULATE DEDUCT WEIGHT (when bags or charges change)\n    // ========================================\n    if (row.item_bags && row.item_charges && \n        row.item_bags > 0 && row.item_charges > 0) {\n        \n        let deduct_bag_weight = row.item_bags * row.item_charges;\n        \n        // Round to 2 decimal places\n        deduct_bag_weight = Math.round(deduct_bag_weight * 100) / 100;\n        \n        frappe.model.set_value(cdt, cdn, 'item_deduct_weight', deduct_bag_weight);\n        \n        // After calculating deduct weight, recalculate arrival weight\n        if (row.item_gross_weight && row.item_gross_weight > 0) {\n            let calculated_arrival_weight = row.item_gross_weight - deduct_bag_weight;\n            calculated_arrival_weight = Math.round(calculated_arrival_weight * 100) / 100;\n            \n            frappe.model.set_value(cdt, cdn, 'item_arrival_weight', calculated_arrival_weight);\n        }\n        \n    } else if (row.item_bags === 0 || row.item_charges === 0) {\n        // Clear deduct weight if bags or charges are 0\n        frappe.model.set_value(cdt, cdn, 'item_deduct_weight', 0);\n        \n        // Recalculate arrival weight when deduct weight becomes 0\n        if (row.item_gross_weight && row.item_gross_weight > 0) {\n            frappe.model.set_value(cdt, cdn, 'item_arrival_weight', row.item_gross_weight);\n        }\n    }\n    \n    // ========================================\n    // 2. CALCULATE GROSS WEIGHT (when arrival weight changes)\n    // Formula: gross_weight = arrival_weight + deduct_weight\n    // ========================================\n    // if (row.item_arrival_weight && row.item_arrival_weight > 0) {\n    //     let current_deduct_weight = row.item_deduct_weight || 0;\n    //     let calculated_gross_weight = row.item_arrival_weight + current_deduct_weight;\n        \n    //     // Round to 2 decimal places\n    //     calculated_gross_weight = Math.round(calculated_gross_weight * 100) / 100;\n        \n    //     frappe.model.set_value(cdt, cdn, 'item_gross_weight', calculated_gross_weight);\n    // } else {\n    //     // Clear gross weight if arrival weight is not valid\n    //     frappe.model.set_value(cdt, cdn, 'item_gross_weight', 0);\n    // }\n    \n    // ========================================\n    // 3. CALCULATE AMOUNT (based on arrival weight and rate)\n    // Formula: amount = arrival_weight × rate\n    // ========================================\n    if (row.item_arrival_weight && row.item_rate && \n        row.item_arrival_weight > 0 && row.item_rate > 0) {\n        \n        // Calculate amount = arrival_weight × rate\n        let calculated_amount = (row.item_arrival_weight * row.item_rate) / 100;\n        \n        // Round to 2 decimal places\n        // calculated_amount = Math.round(calculated_amount * 100) / 100;\n        \n        // Set the calculated amount\n        frappe.model.set_value(cdt, cdn, 'item_amount', calculated_amount);\n        \n    } else {\n        \n        // Clear amount if values are incomplete\n        if (row.item_amount) {\n            frappe.model.set_value(cdt, cdn, 'item_amount', 0);\n        }\n        \n    }\n    \n    // 4. HANDLE SECOND ROW GROSS WEIGHT (Multi Rate Report)\n    // Update second row when first row arrival weight changes\n    // ========================================\n    if (row.idx === 1 && row.item_gross_weight && frm.doc.inward_items.length >= 2) {\n        // Call the existing calculate_auto_gross_weight function for second row\n        let second_row = frm.doc.inward_items[1];\n        \n        setTimeout(() => {\n            calculate_auto_gross_weight(frm, second_row.doctype, second_row.name);\n        }, 300);\n        \n    }\n    \n    // Refresh the child table to show all updates\n    frm.refresh_field('inward_items');\n}\n\nfunction add_default_bag_types(frm) {\n    // Fetch App Settings document using client-side call\n    frappe.call({\n        method: 'frappe.client.get',\n        args: {\n            doctype: 'App Settings',\n            name: 'App Settings' // Assuming single document, adjust name if different\n        },\n        callback: function(response) {\n            if (response.message) {\n                let app_settings = response.message;\n                \n                // Check if default bag types child table exists\n                if (app_settings.default_bag_types && app_settings.default_bag_types.length > 0) {\n                    frm.clear_table('inward_items');\n                    // Add each default bag type to the child table\n                    app_settings.default_bag_types.forEach(function(bag_type_row) {\n                        let child_row = frm.add_child('inward_items');\n                        \n                        // Only set bag type and charges\n                        child_row.item_bag_type = bag_type_row.bag_type;\n                        child_row.item_charges = bag_type_row.charges;\n                    });\n                    \n                    // Refresh the child table to show the new rows\n                    frm.refresh_field('inward_items');\n                }\n            }\n        },\n    });\n}\n\nfunction calculate_bag_count(frm, callback) {\n    let count;\n    \n    // ========================================\n    // Multi Rate Report: Always set bag count to 1\n    // ========================================\n    if (frm.doc.report_type === 'Multi Rate') {\n        count = 1;\n    } else {\n        // ========================================\n        // Other Reports: Calculate based on item count (original logic)\n        // ========================================\n        count = frm.doc.inward_items ? frm.doc.inward_items.length : 0;\n    }\n    \n    // Set the calculated/fixed bag count\n    frm.set_value('bag_type_count', count).then(function() {\n        if (callback) {\n            callback();\n        }\n    });\n}\n\nfunction auto_populate_deductions(frm, add_only_for_new_item = false) {\n    frappe.call({\n        method: 'frappe.client.get',\n        args: {\n            doctype: 'App Settings'\n        },\n        callback: function(r) {\n            if (r.message && r.message.default_deduction_types) {\n                let deduction_types = r.message.default_deduction_types;\n                let bag_type_count;\n\n                if (frm.doc.report_type === 'Multi Rate') {\n                    bag_type_count = 1;\n                } else {\n                    bag_type_count = frm.doc.inward_items.length;\n                }\n                let has_plastic = has_plastic_bag_type(frm);\n\n                if (frm.doc.report_type !== 'Multi Rate' && add_only_for_new_item) {\n                    // Rebuild table with proper order\n                    let existing_deductions = [...frm.doc.deductions];\n                    let new_item_index = bag_type_count - 1;\n                    \n                    // Clear table first\n                    frm.clear_table('deductions');\n                    \n                    // Filter multiple deductions\n                    let multiple_deductions = deduction_types.filter(function(deduction_type) {\n                        return deduction_type.deduction_category === 'multiple';\n                    });\n                    \n                    // Rebuild table with proper mapping\n                    multiple_deductions.forEach(function(deduction_type, type_index) {\n                        for (let item_index = 0; item_index < bag_type_count; item_index++) {\n                            let row = frm.add_child('deductions');\n                            row.deduction_type = deduction_type.deduction_name;\n                            row.required_value = deduction_type.required_value;\n                            \n                            if (deduction_type.deduction_name === 'Damage' || deduction_type.deduction_name === 'UNLOADING' || deduction_type.deduction_name === 'Others') {\n                                row.charges_per_unit = deduction_type.charges_per_unit;\n                            }\n                            \n                            // Copy existing data if this is not the new item\n                            if (item_index !== new_item_index) {\n                                let old_row = existing_deductions.find(function(old_row) {\n                                    return old_row.deduction_type === deduction_type.deduction_name && \n                                           (old_row.idx - 1) % (bag_type_count - 1) === (item_index > new_item_index ? item_index - 1 : item_index);\n                                });\n                                \n                                if (old_row) {\n                                    row.bags = old_row.bags;\n                                    row.charges = old_row.charges;\n                                    row.required_value = old_row.required_value;\n                                    row.actual_value = old_row.actual_value;\n                                    row.difference_value = old_row.difference_value;\n                                    row.deduction_amount = old_row.deduction_amount;\n                                }\n                            }\n                        }\n                    });\n                    \n                    // Add single deductions\n                    deduction_types.forEach(function(deduction_type) {\n                        if (deduction_type.deduction_category === 'single') {\n                            if (deduction_type.deduction_name === 'PP' && !has_plastic_bag_type(frm)) {\n                                return;\n                            }\n                            let old_row = existing_deductions.find(function(old_row) {\n                                return old_row.deduction_type === deduction_type.deduction_name;\n                            });\n                            \n                            let row = frm.add_child('deductions');\n                            row.deduction_type = deduction_type.deduction_name;\n                            \n                            if (old_row) {\n                                row.bags = old_row.bags;\n                                row.charges = old_row.charges;\n                                row.required_value = old_row.required_value;\n                                row.actual_value = old_row.actual_value;\n                                row.difference_value = old_row.difference_value;\n                                row.deduction_amount = old_row.deduction_amount;\n                            }\n                        }\n                    });\n                    \n                } else {\n                    // Clear and repopulate everything\n                    \n                    if (add_only_for_new_item) {\n                        return ;\n                    }\n                    frm.clear_table('deductions');\n                    deduction_types.forEach(function(deduction_type) {\n                        if (deduction_type.deduction_category === 'multiple') {\n                            for (let i = 0; i < bag_type_count; i++) {\n                                let row = frm.add_child('deductions');\n                                row.deduction_type = deduction_type.deduction_name;\n                                row.required_value = deduction_type.required_value;\n                                row.deduction_category = deduction_type.deduction_category;\n                                if (deduction_type.deduction_name === 'Damage') {\n                                    row.charges_per_unit = deduction_type.charges_per_unit;\n                                }\n                            }\n                        } else if (deduction_type.deduction_category === 'single') {\n                            if (deduction_type.deduction_name === 'PP' && !has_plastic_bag_type(frm)) {\n                                return;\n                            }\n                            let row = frm.add_child('deductions');\n                            row.deduction_type = deduction_type.deduction_name;\n                            row.deduction_category = deduction_type.deduction_category;\n                            if(deduction_type.deduction_name === 'UNLOADING')\n                            {\n                                row.charges_per_unit = deduction_type.charges_per_unit;\n                                \n                                if(frm.doc.gross_weight) \n                                {\n                                    row.deduction_amount = (frm.doc.gross_weight * deduction_type.charges_per_unit) / 100;\n                                }\n                            }\n                            else if (deduction_type.deduction_name === 'Others')\n                            {\n                                row.charges_per_unit = deduction_type.charges_per_unit;\n                                \n                                if(frm.doc.total_amount) \n                                {\n                                    row.deduction_amount = (frm.doc.total_amount * deduction_type.charges_per_unit) / 100;\n                                }\n                            }\n                            else if(deduction_type.deduction_name === 'PP' && frm.doc.report_type === 'Single Report')\n                            {\n                                row.charges_per_unit = deduction_type.charges_per_unit;\n                                \n                                if(frm.doc.gross_weight) \n                                {\n                                    row.deduction_amount = (frm.doc.gross_weight * deduction_type.charges_per_unit) / 100;\n                                }\n                            }\n                            else\n                            {\n                                row.charges_per_unit = deduction_type.charges_per_unit;\n                                row.deduction_amount = deduction_type.charges_per_unit;\n                            }\n                            \n                        }\n                    });\n                }\n                \n                frm.refresh_field('deductions');\n            }\n        }\n    });\n}\n\nfunction has_plastic_bag_type(frm) {\n    return frm.doc.inward_items && frm.doc.inward_items.some(function(item) {\n        return item.item_bag_type && item.item_bag_type.toLowerCase() === 'plastic';\n    });\n}\n\nfunction calculate_deduction_amount(frm, cdt, cdn) {\n    let deduction_row = locals[cdt][cdn];\n    let deduction_idx = deduction_row.idx - 1; // Convert to 0-based index\n    \n    // Get total item details count\n    let item_count = frm.doc.inward_items.length;\n    \n    if (item_count === 0) return;\n    \n    let required = deduction_row.required_value || 0;\n    let actual = deduction_row.actual_value || 0;\n    let difference = actual - required;\n    if(difference <= 0){\n        difference = 0;\n    }\n    \n    // Get charges from deduction table itself\n    let charges = deduction_row.charges_per_unit || 0;\n    \n        // Get deduction type\n    let deduction_type = deduction_row.deduction_type || '';\n    let amount = 0;\n    \n    \n    if (deduction_type.toLowerCase() !== 'moise') {\n        // Set the difference\n        frappe.model.set_value(cdt, cdn, 'difference_value', difference);\n    }\n    \n    // frappe.model.set_value(cdt, cdn, 'difference_value', difference);\n\n    \n    // ========================================\n    // MULTI RATE REPORT vs OTHER REPORTS LOGIC\n    // ========================================\n    \n    if (frm.doc.report_type === 'Multi Rate') {\n        \n        // ========================================\n        // MULTI RATE: Use TOTAL values from form fields\n        // ========================================\n        \n        let total_amount = frm.doc.total_amount || 0;\n        let total_arrival_weight = frm.doc.total_arrival_weight || 0;\n        let total_gross_weight = frm.doc.total_gross_weight || 0;\n        \n        // Calculate amount based on deduction type using TOTALS\n        if (deduction_type.toLowerCase() === 'moise') {\n            // Check if tiered calculation is enabled for Moise\n            check_moise_tiered_calculation(actual, required, total_amount, function(calculated_amount) {\n                frappe.model.set_value(cdt, cdn, 'deduction_amount', calculated_amount);\n            },cdt,cdn);\n            return; // Exit early for Moise as it's async\n            \n        } else if (deduction_type.toLowerCase() === 'damage') {\n            // Damage = (diff * charges * total_arrival_weight) / 100\n            amount = (difference * charges * total_gross_weight) / 100;\n            \n        } else if (deduction_type.toLowerCase() === 's/s') {\n            // S/S = (diff * total_amount) / 100\n            amount = (difference * total_amount) / 100;\n        }\n        \n    } else {\n        \n        // ========================================\n        // MULTI STATE & SINGLE REPORT: Use individual item values (original logic)\n        // ========================================\n        \n        // Calculate which item this deduction maps to\n        let item_index = deduction_idx % item_count;\n        let corresponding_item = frm.doc.inward_items[item_index];\n        if (!corresponding_item) return;\n        let item_gross_weight = corresponding_item.item_gross_weight || 0;\n        let rate = corresponding_item.item_rate || 0;\n        // let item_amount = corresponding_item.item_amount || 0;\n        let item_amount = ((item_gross_weight - corresponding_item.item_deduct_weight) * rate) / 100;\n        \n        // Calculate amount based on deduction type using INDIVIDUAL values\n        if (deduction_type.toLowerCase() === 'moise') {\n            // Check if tiered calculation is enabled for Moise\n            check_moise_tiered_calculation(actual, required, item_amount, function(calculated_amount) {\n                frappe.model.set_value(cdt, cdn, 'deduction_amount', calculated_amount);\n            },cdt,cdn);\n            return; // Exit early for Moise as it's async\n            \n        } else if (deduction_type.toLowerCase() === 'damage') {\n            // Damage = (diff * charges * item_gross_weight) / 100\n            amount = (difference * charges * item_gross_weight) / 100;\n            \n        } else if (deduction_type.toLowerCase() === 's/s') {\n            // S/S = (diff * item_amount) / 100\n            amount = (difference * item_amount) / 100;\n        }\n    }\n    \n    // Set the calculated amount (for non-Moise deductions)\n    frappe.model.set_value(cdt, cdn, 'deduction_amount', amount);\n}\n\n// function to update deduction bags\nfunction update_deduction_bags_for_item(frm, cdt, cdn) {\n \n  let item_row = locals[cdt][cdn];\n  let item_idx = item_row.idx - 1; // Convert to 0-based index\n  let new_bags = item_row.item_bags || 0;\n   \n  // Get total item count\n  let item_count = frm.doc.inward_items.length;\n   \n    // Update all deduction rows that map to this item\n    frm.doc.deductions.forEach(function(deduction_row, deduction_idx) {\n        if (deduction_row.deduction_category === 'multiple') {\n            // Check if this deduction row maps to the changed item\n            let mapped_item_index = deduction_idx % item_count;\n            if (mapped_item_index === item_idx) {\n                // This deduction row corresponds to the changed item\n                frappe.model.set_value(\n                    'Inward Deduction',\n                    deduction_row.name,\n                    'bags',\n                    new_bags\n                );\n            }\n        }\n    });\n\n  frm.refresh_field('Inward Deduction');\n}\n\nfunction remove_mapped_deduction_rows(frm, deleted_item_index) {\n    let item_count = frm.doc.inward_items.length + 1; // +1 because item was just deleted\n    let rows_to_remove = [];\n    \n    // Find all deduction rows that were mapped to the deleted item\n    frm.doc.deductions.forEach(function(deduction_row, deduction_idx) {\n        let mapped_item_index = deduction_idx % item_count;\n        \n        // Delete only if mapped AND NOT \"multiple\"\n        if (mapped_item_index === deleted_item_index && deduction_row.deduction_category !== 'single') {\n            rows_to_remove.push(deduction_row.name);\n        }\n    });\n    \n    // Remove rows in reverse order\n    for (let i = frm.doc.deductions.length - 1; i >= 0; i--) {\n        if (rows_to_remove.includes(frm.doc.deductions[i].name)) {\n            frm.doc.deductions.splice(i, 1);\n        }\n    }\n    \n    // Re-index all remaining rows to reset No. column\n    frm.doc.deductions.forEach(function(row, index) {\n        row.idx = index + 1;\n    });\n    \n    frm.refresh_field('deductions');\n}\n\nfunction check_moise_tiered_calculation(actual, required, item_amount, callback,cdt,cdn) {\n    frappe.call({\n        method: 'frappe.client.get',\n        args: {\n            doctype: 'App Settings'\n        },\n        callback: function(r) {\n            if (r.message && r.message.default_deduction_types) {\n                // Find Moise deduction configuration\n                let moise_config = r.message.default_deduction_types.find(function(deduction) {\n                    return deduction.deduction_name.toLowerCase() === 'moise';\n                });\n                \n                if (moise_config && moise_config.has_tiered_calculation) {\n                     // Get tier ranges from App Settings child table\n                    let tier_ranges = r.message.deduction_tier_range || []; // Child table data\n                    calculate_moise_tiered_amount(actual, required, item_amount, tier_ranges, function(amount, difference) {\n                        // Set the difference value first\n                        frappe.model.set_value(cdt, cdn, 'difference_value', difference);\n                        // Then return the amount through original callback\n                        callback(amount);\n                    });\n                } else {\n                    // Use regular calculation\n                    let difference = actual - required;\n                    if(difference <= 0){\n                        difference = 0;\n                    }\n                    frappe.model.set_value(cdt, cdn, 'difference_value', difference);\n                    let amount = (difference * item_amount) / 100;\n                    callback(amount);\n                }\n            } else {\n                // Fallback to regular calculation\n                let difference = actual - required;\n                if(difference <= 0){\n                    difference = 0;\n                }\n                frappe.model.set_value(cdt, cdn, 'difference_value', difference);\n                let amount = (difference * item_amount) / 100;\n                callback(amount);\n            }\n        }\n    });\n}\n\nfunction calculate_moise_tiered_amount(actual, required, item_amount, tier_ranges, callback) {\n    \n    // If actual <= required, no charges apply\n    if (actual <= required) {\n        callback(0, 0);\n        return;\n    }\n    \n    if (!tier_ranges || tier_ranges.length === 0) {\n        let difference = actual - required;\n        if(difference <= 0){\n            difference = 0;\n        }\n        let amount = (difference * item_amount) / 100;\n        callback(amount, difference); // callback(amount, difference)\n        return;\n    }\n    \n    let total_weighted_diff = 0;\n    \n    // Sort tier ranges by range_from to ensure proper order\n    let sorted_ranges = tier_ranges.sort(function(a, b) {\n        return a.range_from - b.range_from;\n    });\n    \n    \n    for (let i = 0; i < sorted_ranges.length; i++) {\n        let tier = sorted_ranges[i];\n        let tier_start = tier.range_from;\n        let tier_end = tier.range_to;\n        \n        // Skip if actual value hasn't reached this tier\n        if (actual < tier_start) {\n            break;\n        }\n        \n        // Calculate the portion that falls in this tier\n        let range_start, range_end;\n        \n        if (i === 0) {\n            // First tier: start from (required + 1)\n            range_start = required + 1;\n        } else {\n            // Other tiers: start from tier_start\n            range_start = tier_start;\n        }\n        \n        // End is minimum of tier_end and actual\n        range_end = Math.min(tier_end, actual);\n        \n        if (range_end >= range_start) {\n            let tier_diff = range_end - range_start + 1; // +1 for inclusive counting\n            let weighted_diff = tier_diff * tier.multiplier;\n            total_weighted_diff += weighted_diff;\n        }\n    }\n    \n    let final_amount = (total_weighted_diff * item_amount) / 100;\n    \n    callback(final_amount, total_weighted_diff);\n}\n\nfunction load_bag_type_options(frm) {\n    frappe.call({\n        method: 'frappe.client.get',\n        args: {\n            doctype: 'App Settings'\n        },\n        callback: function(r) {\n            if (r.message && r.message.default_bag_types) {\n                // Extract bag type names from default_bag_types\n                let bag_type_options = r.message.default_bag_types.map(function(bag) {\n                    return bag.bag_type;\n                });\n                \n                // Update grid field options\n                if (frm.fields_dict.inward_items && frm.fields_dict.inward_items.grid) {\n                    frm.fields_dict.inward_items.grid.update_docfield_property('item_bag_type', 'options', bag_type_options.join('\\n'));\n                }\n                \n                // Refresh the child table to show updated options\n                frm.refresh_field('inward_items');\n            }\n        }\n    });\n}\n\nfunction validate_bag_count(frm) {\n    let total_bags = 0;\n\n    (frm.doc.inward_items || []).forEach(row => {\n        total_bags += row.item_bags || 0;\n    });\n\n    if (total_bags > (frm.doc.inward_total_bags || 0)) {\n        frappe.msgprint({\n            title: __('Bag Count Exceeded'),\n            message: __('Sum of item bags cannot be greater than Total Bags'),\n            indicator: 'red'\n        });\n    }\n}\n\nfunction calculate_and_update_debit_note(frm) {\n    // Get the required values\n    let vendor_amount = frm.doc.vendor_amount || 0;\n    let sub_total = frm.doc.sub_total || 0;\n    let rate_per_quintal = frm.doc.rate_per_quintal || 0;\n    let total_gross_weight = frm.doc.total_gross_weight || 0;\n    let total_arrival_weight = frm.doc.total_arrival_weight || 0;\n    \n    // Calculate the amount and deducted weight\n    let amount = vendor_amount - sub_total;\n    let deducted_weight_kg = 0;\n    \n    // Calculate deducted weight only if rate_per_quintal is not zero\n    if (rate_per_quintal > 0 && total_gross_weight && total_arrival_weight) {\n        deducted_weight_kg = total_gross_weight - total_arrival_weight;\n    }\n    \n    // Check if there's already a row in debit_note child table\n    if (frm.doc.debit_note && frm.doc.debit_note.length > 0) {\n        // Update the first row\n        let row = frm.doc.debit_note[0];\n        row.amount = amount;\n        row.deducted_weight_kg = deducted_weight_kg;\n        \n        // Set default particulars if not already set\n        if (!row.particulars) {\n            row.particulars = \"Weight Shortage\";\n        }\n        \n        frm.refresh_field('debit_note');\n    } else {\n        // Add a new row to the child table\n        let child = frm.add_child('debit_note');\n        child.particulars = \"Weight Shortage\";\n        child.amount = amount;\n        child.deducted_weight_kg = deducted_weight_kg;\n        \n        frm.refresh_field('debit_note');\n    }\n    \n    // Refresh the form to show updated values\n    frm.refresh();\n}\n\nfunction update_unloading_deduction(frm) {\n    if (!frm.doc.gross_weight) {\n        return;\n    }\n    \n    // Find the row with deduction_type = 'UNLOADING'\n    let unloading_row = null;\n\n    frm.doc.deductions.forEach(function(row) {\n        if (row.deduction_type === 'UNLOADING') {\n            unloading_row = row;\n            return false; // break the loop\n        }\n    });\n    \n    \n    if (unloading_row) {\n        // Calculate new amount: (gross_weight * charges_per_unit) / 100\n        let new_amount = (frm.doc.gross_weight * unloading_row.charges_per_unit) / 100;\n        \n        // Update the amount field\n        frappe.model.set_value(unloading_row.doctype, unloading_row.name, 'deduction_amount', new_amount);\n        \n        // Refresh the child table\n        frm.refresh_field('deduction');\n    }\n}\n\nfunction update_others_deduction(frm) {\n    if (!frm.doc.total_amount) {\n        return;\n    }\n    \n    // Find the row with deduction_type = 'Others'\n    let others_row = null;\n    frm.doc.deductions.forEach(function(row) {\n        if (row.deduction_type === 'Others') {\n            others_row = row;\n            return false; // break the loop\n        }\n    });\n    \n    \n    if (others_row) {\n        // Calculate new amount: (total_amount * charges_per_unit) / 100\n        let new_amount = (frm.doc.total_amount * others_row.charges_per_unit) / 100;\n        \n        // Update the amount field\n        frappe.model.set_value(others_row.doctype, others_row.name, 'deduction_amount', new_amount);\n        \n        // Refresh the child table\n        frm.refresh_field('deductions');\n    }\n}\n\nfunction load_items_by_report_type(frm) {\n    let report_type = frm.doc.report_type;\n    \n    if (!report_type) {\n        return;\n    }\n    \n    // Fetch App Settings with default bag types\n    frappe.call({\n        method: 'frappe.client.get',\n        args: {\n            doctype: 'App Settings',\n            name: 'App Settings'\n        },\n        callback: function(response) {\n            if (response.message && response.message.default_bag_types) {\n                let app_settings = response.message;\n                let bag_types = app_settings.default_bag_types;\n                \n                // Clear existing items\n                frm.clear_table('inward_items');\n                \n                // Load items based on report type\n                let loaded_count = 0;\n                \n                switch (report_type) {\n                    case 'Single Report':\n                        loaded_count = load_single_report_items(frm, bag_types);\n                        calculate_bag_count(frm);\n                        auto_populate_deductions(frm);\n                        break;\n                    case 'Multi Report':\n                        loaded_count = load_multi_state_report_items(frm, bag_types);\n                        calculate_bag_count(frm);\n                        auto_populate_deductions(frm);\n                        break;\n                    case 'Multi Rate':\n                        loaded_count = load_multi_rate_report_items(frm, bag_types);\n                        calculate_bag_count(frm);\n                        auto_populate_deductions(frm);\n                        break;\n                    default:\n                        frappe.show_alert({\n                            message: 'Invalid report type selected',\n                            indicator: 'red'\n                        });\n                        return;\n                }\n                \n                // Refresh child table to show new items\n                frm.refresh_field('inward_items');\n                \n            } else {\n                frappe.show_alert({\n                    message: 'No default bag types found in App Settings',\n                    indicator: 'orange'\n                });\n            }\n        },\n        error: function(error) {\n            frappe.show_alert({\n                message: 'Failed to load App Settings',\n                indicator: 'red'\n            });\n        }\n    });\n}\n\nfunction load_single_report_items(frm, bag_types) {\n    if (bag_types && bag_types.length > 0) {\n        // Load only FIRST record from App Settings default bag types\n        let first_item = bag_types[0];\n        let child_row = frm.add_child('inward_items');\n        \n        child_row.item_bag_type = first_item.bag_type;\n        child_row.item_charges = first_item.charges;\n        \n        if (frm.doc.rate_per_quintal) {\n            child_row.item_rate = frm.doc.rate_per_quintal;\n        }\n        \n        if (frm.doc.inward_total_bags) {\n            child_row.item_bags = frm.doc.inward_total_bags;\n        }\n        \n        if (frm.doc.inward_total_bags && child_row.item_charges) {\n            child_row.item_deduct_weight = child_row.item_charges * child_row.item_bags;\n        }\n        \n        if (frm.doc.gross_weight) {\n            child_row.item_gross_weight = frm.doc.gross_weight;\n        }\n        \n        if (frm.doc.gross_weight && child_row.item_deduct_weight) {\n            child_row.item_arrival_weight = frm.doc.gross_weight - child_row.item_deduct_weight;\n        }\n        \n        if (child_row.item_rate && child_row.item_arrival_weight) {\n            child_row.item_amount = (child_row.item_rate * child_row.item_arrival_weight)/100;\n        }\n\n        return 1;\n    }\n    return 0;\n}\n\nfunction load_multi_state_report_items(frm, bag_types) {\n    if (bag_types && bag_types.length > 0) {\n        // Load ALL records from App Settings default bag types (your current logic)\n        bag_types.forEach(function(bag_item, index) {\n            let child_row = frm.add_child('inward_items');\n            \n            child_row.item_bag_type = bag_item.bag_type;\n            child_row.item_charges = bag_item.charges;\n            \n        if (frm.doc.rate_per_quintal) {\n            child_row.item_rate = frm.doc.rate_per_quintal;\n        }\n        });\n        return bag_types.length;\n    }\n    return 0;\n}\n\nfunction load_multi_rate_report_items(frm, bag_types) {\n    if (bag_types && bag_types.length > 0) {\n        // First record: Load from App Settings default bag types (first one)\n        let first_item = bag_types[0];\n        let first_row = frm.add_child('inward_items');\n        \n        first_row.item_bag_type = first_item.bag_type;\n        first_row.item_charges = first_item.charges;\n        \n        if (frm.doc.rate_per_quintal) {\n            first_row.item_rate = frm.doc.rate_per_quintal;\n        }\n        \n        if (frm.doc.inward_total_bags) {\n            first_row.item_bags = frm.doc.inward_total_bags;\n        }\n        \n        if (frm.doc.inward_total_bags && first_row.item_charges) {\n            first_row.item_deduct_weight = first_row.item_charges * first_row.item_bags;\n        }\n        \n        // Second record: Add empty row with item_bags set to 0\n        let second_row = frm.add_child('inward_items');\n        second_row.item_bags = 0;  // Set bags to 0 for empty row\n        \n        // Auto-calculate arrival weight for second row using existing function\n        // setTimeout(() => {\n        //     calculate_auto_arrival_weight(frm, second_row.doctype, second_row.name);\n        // }, 300);\n        \n        return 2;\n    }\n    return 0;\n}\n\nfunction update_first_row_bag_type(frm) {\n    \n    // Only auto-populate if report type is \"Single Report\" or \"Multi Rate Report\"\n    if ((frm.doc.report_type === 'Single Report') && \n        frm.doc.inward_total_bags && frm.doc.inward_items && frm.doc.inward_items.length > 0) {\n        \n        // Update only the FIRST row in inward_items table\n        let first_row = frm.doc.inward_items[0];\n        frappe.model.set_value(first_row.doctype, first_row.name, 'item_bags', frm.doc.inward_total_bags);\n        // Refresh the child table to show updates\n        frm.refresh_field('inward_items');\n        \n    }\n    \n    if (frm.doc.report_type === 'Single Report' && \n        frm.doc.gross_weight && frm.doc.inward_items && frm.doc.inward_items.length > 0) {\n        // Update only the FIRST row in inward_items table\n        let first_row = frm.doc.inward_items[0];\n        frappe.model.set_value(first_row.doctype, first_row.name, 'item_gross_weight', frm.doc.gross_weight);\n        // Refresh the child table to show updates\n        frm.refresh_field('inward_items');\n    }\n    \n    return true;\n}\n\n\nfunction calculate_auto_gross_weight(frm, cdt, cdn) {\n    if (frm.doc.report_type !== 'Multi Rate') return;\n    \n    let current_row = locals[cdt][cdn];\n    let parent_gross_weight = frm.doc.gross_weight || 0;\n    \n    if (parent_gross_weight <= 0) {\n        return;\n    }\n    \n    // Calculate sum of all OTHER rows' gross weight (excluding current row)\n    let sum_other_gross_weights = 0;\n    \n    if (frm.doc.inward_items && frm.doc.inward_items.length > 0) {\n        frm.doc.inward_items.forEach(function(item_row) {\n            // Skip current row and only sum rows that have gross weight\n            if (item_row.name !== current_row.name && item_row.item_gross_weight) {\n                sum_other_gross_weights += item_row.item_gross_weight;\n            }\n        });\n    }\n    \n    // Calculate remaining gross weight\n    let calculated_gross_weight = parent_gross_weight - sum_other_gross_weights;\n    \n    // Ensure it's not negative\n    if (calculated_gross_weight < 0) {\n        calculated_gross_weight = 0;\n    }\n    \n    // Round to 2 decimal places\n    calculated_gross_weight = Math.round(calculated_gross_weight * 100) / 100;\n    \n    // Set the calculated arrival weight\n    frappe.model.set_value(cdt, cdn, 'item_gross_weight', calculated_gross_weight);\n    \n    \n    // Trigger multi rate calculation for this row\n    setTimeout(() => {\n        calculate_multi_rate_amount(frm, cdt, cdn);\n    }, 200);\n}\n\nfunction update_related_deductions(frm) {\n    // For Multi Rate Report, update totals first\n    if (frm.doc.report_type === 'Multi Rate') {\n        frm.set_value('total_amount', frm.doc.total_amount);\n        frm.set_value('total_arrival_weight', frm.doc.total_arrival_weight);\n    }\n    \n    // Recalculate all deductions\n    frm.doc.deductions.forEach(function(deduction) {\n        if (deduction.deduction_category === 'multiple') {\n            calculate_deduction_amount(frm, deduction.doctype, deduction.name);\n        }\n    });\n}\n\nfunction check_and_add_pp_deduction(frm) {\n    // Only proceed if plastic bag type exists\n    if (!has_plastic_bag_type(frm)) {\n        return;\n    }\n    \n    // Check if PP deduction already exists\n    let pp_exists = false;\n    if (frm.doc.deductions) {\n        pp_exists = frm.doc.deductions.some(function(row) {\n            return row.deduction_type === 'PP';\n        });\n    }\n    \n    // If PP doesn't exist, add it\n    if (!pp_exists) {\n        add_pp_deduction_from_settings(frm);\n    }\n}\n\nfunction remove_pp_deduction(frm) {\n    if (!frm.doc.deductions) return;\n    \n    // Find and remove PP deduction rows (reverse loop to avoid index issues)\n    for (let i = frm.doc.deductions.length - 1; i >= 0; i--) {\n        if (frm.doc.deductions[i].deduction_type === 'PP') {\n            frm.doc.deductions.splice(i, 1);\n        }\n    }\n    \n    // Refresh the deductions table\n    frm.refresh_field('deductions');\n}\n\nfunction add_pp_deduction_from_settings(frm) {\n    frappe.call({\n        method: 'frappe.client.get',\n        args: {\n            doctype: 'App Settings'\n        },\n        callback: function(r) {\n            if (r.message && r.message.default_deduction_types) {\n                let pp_deduction_type = r.message.default_deduction_types.find(function(deduction_type) {\n                    return deduction_type.deduction_name === 'PP';\n                });\n                \n                if (pp_deduction_type) {\n                    let row = frm.add_child('deductions');\n                    row.deduction_type = pp_deduction_type.deduction_name;\n                    row.deduction_category = pp_deduction_type.deduction_category;\n                    row.charges_per_unit = pp_deduction_type.charges_per_unit;\n                    row.deduction_amount = pp_deduction_type.charges_per_unit;\n                    \n                    frm.refresh_field('deductions');\n                    \n                    // Set read-only property\n                    setTimeout(() => {\n                        let grid_row = frm.fields_dict.deductions.grid.grid_rows_by_docname[row.name];\n                        if (grid_row) {\n                            let deduction_amount_field = grid_row.docfields.find(field => field.fieldname === 'deduction_amount');\n                            if (deduction_amount_field) {\n                                deduction_amount_field.read_only = pp_deduction_type.deduction_category !== 'miscellaneous' ? 1 : 0;\n                            }\n                        }\n                    }, 100);\n                }\n            }\n        }\n    });\n}\n\n// Function to update PP deduction amount\nfunction update_pp_deduction(frm) {\n    if (!frm.doc.deductions) return;\n    \n    // Find PP deduction row\n    let pp_row = null;\n    frm.doc.deductions.forEach(function(row) {\n        if (row.deduction_type === 'PP') {\n            pp_row = row;\n            return false; // break the loop\n        }\n    });\n    \n    if (pp_row) {\n        // Calculate plastic gross weight\n        let plastic_weight_kg = calculate_plastic_gross_weight(frm);\n        // Calculate new amount: (plastic_weight_kg * charges_per_unit) / 100\n        // Since charges are per quintal and 1 quintal = 100 kg\n        let new_amount = (plastic_weight_kg * pp_row.charges_per_unit) / 100;\n        // Update the amount field\n        frappe.model.set_value(pp_row.doctype, pp_row.name, 'deduction_amount', new_amount);\n        \n        // Refresh the child table\n        frm.refresh_field('deductions');\n    }\n}\n\n\n// Function to calculate plastic gross weight sum\nfunction calculate_plastic_gross_weight(frm) {\n    let plastic_weight = 0;\n    if (frm.doc.inward_items) {\n        frm.doc.inward_items.forEach(function(item) {\n            if (item.item_bag_type && item.item_bag_type.toLowerCase() === 'plastic' && item.item_gross_weight) {\n                plastic_weight += parseFloat(item.item_gross_weight) || 0;\n            }\n        });\n    }\n    return plastic_weight;\n}",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Sauda",
  "enabled": 1,
  "modified": "2025-08-19 13:50:22.100595",
  "module": null,
  "name": "Sauda Invoice Number Simple",
  "script": "\nfrappe.ui.form.on('Sauda', {\n    refresh: function(frm) {\n        // Auto-generate for new documents\n        if (frm.is_new() && !frm.doc.sauda_invoice_no) {\n            generate_simple_invoice_number(frm);\n        }\n    },\n    \n    before_save: function(frm) {\n        // Ensure invoice number exists\n        if (!frm.doc.sauda_invoice_no) {\n            generate_simple_invoice_number(frm);\n        }\n    }\n});\n\nfunction generate_simple_invoice_number(frm) {\n    // Get current year\n    let year = new Date().getFullYear();\n    \n    // Get count of existing Saudas this year to determine next number\n    frappe.call({\n        method: 'frappe.client.get_count',\n        args: {\n            doctype: 'Sauda',\n            filters: {\n                creation: ['>=', year + '-01-01'],\n                sauda_invoice_no: ['like', 'INV-S-' + year + '%']\n            }\n        },\n        callback: function(r) {\n            let count = r.message || 0;\n            let next_number = count + 1;\n            let invoice_no = `INV-S-${year}-${String(next_number).padStart(4, '0')}`;\n            \n            // Check if this number already exists\n            frappe.call({\n                method: 'frappe.client.get_list',\n                args: {\n                    doctype: 'Sauda',\n                    filters: {\n                        sauda_invoice_no: invoice_no\n                    },\n                    limit: 1\n                },\n                callback: function(check_result) {\n                    if (check_result.message && check_result.message.length > 0) {\n                        // If exists, try next number\n                        invoice_no = `INV-S-${year}-${String(next_number + 1).padStart(4, '0')}`;\n                    }\n                    \n                    frm.set_value('sauda_invoice_no', invoice_no);\n                }\n            });\n        }\n    });\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Inward",
  "enabled": 1,
  "modified": "2025-08-19 14:00:56.610515",
  "module": null,
  "name": "Inward Invoice Number Simple",
  "script": "\nfrappe.ui.form.on('Inward', {\n    refresh: function(frm) {\n        // Auto-generate for new documents\n        if (frm.is_new() && !frm.doc.inward_invoice_no) {\n            generate_inward_invoice_number(frm);\n        }\n    },\n    \n    before_save: function(frm) {\n        // Ensure invoice number exists\n        if (!frm.doc.inward_invoice_no) {\n            generate_inward_invoice_number(frm);\n        }\n    }\n});\n\nfunction generate_inward_invoice_number(frm) {\n    // Get current year\n    let year = new Date().getFullYear();\n    \n    // Get count of existing Inwards this year to determine next number\n    frappe.call({\n        method: 'frappe.client.get_count',\n        args: {\n            doctype: 'Inward',\n            filters: {\n                creation: ['>=', year + '-01-01'],\n                inward_invoice_no: ['like', 'INV-I-' + year + '%']\n            }\n        },\n        callback: function(r) {\n            let count = r.message || 0;\n            let next_number = count + 1;\n            let invoice_no = `INV-I-${year}-${String(next_number).padStart(4, '0')}`;\n            \n            // Check if this number already exists\n            frappe.call({\n                method: 'frappe.client.get_list',\n                args: {\n                    doctype: 'Inward',\n                    filters: {\n                        inward_invoice_no: invoice_no\n                    },\n                    limit: 1\n                },\n                callback: function(check_result) {\n                    if (check_result.message && check_result.message.length > 0) {\n                        // If exists, try next number\n                        invoice_no = `INV-I-${year}-${String(next_number + 1).padStart(4, '0')}`;\n                    }\n                    \n                    frm.set_value('inward_invoice_no', invoice_no);\n                }\n            });\n        }\n    });\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Sauda",
  "enabled": 0,
  "modified": "2025-09-08 18:58:33.646664",
  "module": "saudas",
  "name": "Sauda Customer Email Auto-fill",
  "script": "frappe.ui.form.on('Sauda', {\n    customer: function(frm) {\n        if (frm.doc.customer) {\n            frappe.call({\n                method: \"frappe.client.get_value\",\n                args: {\n                    doctype: \"Customer\",\n                    filters: { name: frm.doc.customer },\n                    fieldname: \"email\" \n                },\n                callback: function(r) {\n                    if (r.message && r.message.email) {\n                        frm.set_value('customer_email', r.message.email);\n                    } else {\n                        frm.set_value('customer_email', '');\n                    }\n                }\n            });\n        } else {\n            frm.set_value('customer_email', '');\n        }\n    }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Broker",
  "enabled": 1,
  "modified": "2025-09-22 15:59:38.599259",
  "module": "Kisan Warehouse",
  "name": "Broker Validations",
  "script": "frappe.ui.form.on('Broker', {\n    before_save: function(frm) {\n        if (frm.doc.bank_account_no) {\n            // Check if account number contains only digits\n            if (!/^\\d+$/.test(frm.doc.bank_account_no)) {\n                frappe.msgprint({\n                    title: __('Validation Error'),\n                    message: __('Account number must contain only numbers'),\n                    indicator: 'red'\n                });\n                frappe.validated = false; // This prevents the form from saving\n                return false;\n            }\n        }\n        if (!frm.doc.broker_consent) {\n            frappe.msgprint({\n                title: __('Consent Required'),\n                message: __('Please check the consent checkbox before saving.'),\n                indicator: 'red'\n            });\n            frappe.validated = false;\n            return false;\n        }\n    },\n    \n    // Change label based on broker type\n    broker_type: function(frm) {\n        if (frm.doc.broker_type == 'Individual / Farmer') {\n            frm.set_df_property('last_name', 'reqd', 1); \n            frm.set_df_property('first_name', 'label', 'First Name');\n        } else {\n            frm.set_df_property('first_name', 'label', 'Broker Name');\n            frm.set_df_property('last_name', 'reqd', 0); \n            frm.set_value('last_name', '');\n        }\n    }\n});\n\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Customer",
  "enabled": 1,
  "modified": "2025-09-25 10:45:40.356618",
  "module": null,
  "name": "Customer Validations",
  "script": "frappe.ui.form.on('Customer', {\n    before_save: function(frm) {\n        if (frm.doc.bank_account_no) {\n            // Check if account number contains only digits\n            if (!/^\\d+$/.test(frm.doc.bank_account_no)) {\n                frappe.msgprint({\n                    title: __('Validation Error'),\n                    message: __('Account number must contain only numbers'),\n                    indicator: 'red'\n                });\n                frappe.validated = false; // This prevents the form from saving\n                return false;\n            }\n        }\n        \n        if (!frm.doc.customer_consent) {\n            frappe.msgprint({\n                title: __('Consent Required'),\n                message: __('Please check the consent checkbox to move further'),\n                indicator: 'red'\n            });\n            frappe.validated = false;\n            return false;\n        }\n    },\n    \n    // Change label based on customer type\n    customer_type: function(frm) {\n        if (frm.doc.customer_type == 'Individual / Farmer') {\n            frm.set_df_property('last_name', 'reqd', 1); \n            frm.set_df_property('first_name', 'label', 'First Name');\n        } else {\n            frm.set_df_property('first_name', 'label', 'Party Name');\n            frm.set_df_property('last_name', 'reqd', 0); \n            frm.set_value('last_name', '');\n        }\n        auto_fill_account_holder(frm);\n    },\n        // Auto-fill when any name field changes\n    first_name: function(frm) { auto_fill_account_holder(frm); },\n    middle_name: function(frm) { auto_fill_account_holder(frm); },\n    last_name: function(frm) { auto_fill_account_holder(frm); },\n});\n\nfunction auto_fill_account_holder(frm) {\n    let name = \"\";\n    \n    if (frm.doc.customer_type === \"Individual / Farmer\") {\n        // Individual: first + middle + last\n        let parts = [frm.doc.first_name, frm.doc.middle_name, frm.doc.last_name]\n                   .filter(n => n && n.trim()) // Remove empty values\n                   .map(n => n.trim());        // Trim spaces\n        name = parts.join(\" \");\n    } else {\n        \n        frm.set_value('bank_account_name', '');\n        name = frm.doc.first_name || \"\";\n    }\n    \n    if (name && name !== frm.doc.bank_account_name) {\n        frm.set_value('bank_account_name', name);\n    }\n}\n\n\n\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Sauda",
  "enabled": 1,
  "modified": "2025-09-08 18:56:15.823576",
  "module": null,
  "name": "Sauda Broker Email Auto-fill",
  "script": "frappe.ui.form.on('Sauda', {\n    broker: function(frm) {\n        if (frm.doc.customer) {\n            frappe.call({\n                method: \"frappe.client.get_value\",\n                args: {\n                    doctype: \"Broker\",\n                    filters: { name: frm.doc.broker },\n                    fieldname: \"email\" \n                },\n                callback: function(r) {\n                    if (r.message && r.message.email) {\n                        frm.set_value('broker_email', r.message.email);\n                    } else {\n                        frm.set_value('broker_email', '');\n                    }\n                }\n            });\n        } else {\n            frm.set_value('broker_email', '');\n        }\n    }\n});\n",
  "view": "Form"
 }
]